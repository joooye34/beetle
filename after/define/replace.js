// Generated by CoffeeScript 1.8.0
(function() {
  var Formator, endReg, globalFLag, markReg, namesReg, noWrapperStr, pathsReg, requireSplit, specialCharReg, specialCharStr, startNoWrapperReg, startWithWrapperReg, util, withWrapperStr;

  util = require('../util');

  startNoWrapperReg = /define [\s\S]*\[/;

  startWithWrapperReg = /define\([\s\S]*\[/;

  endReg = /->/;

  globalFLag = 'G_';

  namesReg = /,[\s\S]*\(([\s\S]*)\)/;

  pathsReg = /\[([\s\S]*)\]/;

  markReg = /[\'\"]/g;

  requireSplit = /\n|,/;

  specialCharReg = /\W/g;

  specialCharStr = '_';

  noWrapperStr = 'define (require, exports, module) ->';

  withWrapperStr = 'define((require, exports, module) ->';

  Formator = (function() {
    Formator.prototype.fileList = [];

    Formator.prototype.requires = [];

    Formator.prototype.start = -1;

    Formator.prototype.end = -1;

    Formator.prototype.hasWrapper = false;

    function Formator(fileList, options) {
      var i, item;
      this.fileList = fileList;
      for (i in options) {
        item = options[i];
        this[i] = item;
      }
    }

    Formator.prototype.initStartAndEnd = function() {
      var line, list, _i, _len;
      list = this.fileList;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        line = list[_i];
        if (util.isSpaceLine(line) || util.isAnnotation(line)) {
          continue;
        }
        if (this.start < 0) {
          if (startNoWrapperReg.test(line)) {
            this.hasWrapper = false;
            this.start = i;
          } else if (startWithWrapperReg.test(line)) {
            this.hasWrapper = true;
            this.start = i;
          }
        }
        this.end = i + 1;
        if (endReg.test(line)) {
          break;
        }
      }
      return this;
    };

    Formator.prototype.parseRequireStr = function(str, isKeepAnnotation) {
      var list, re, tmp, _i, _len;
      if (!str) {
        return [];
      }
      list = str.split(requireSplit);
      re = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        tmp = list[_i];
        tmp = tmp.trim().replace(markReg, '');
        if (!isKeepAnnotation) {
          tmp = util.trimAnnotation(tmp);
        }
        if (!util.isSpaceLine(tmp) && !util.isAnnotation(tmp)) {
          re.push(tmp);
        }
      }
      return re;
    };

    Formator.prototype.initRequires = function() {
      var defineStr, i, isKeepAnnotation, nameList, nameMatch, nameStr, pathList, pathMatch, pathStr, requires, _i, _len;
      defineStr = this.fileList.slice(this.start, this.end).join('\n');
      nameList = [];
      pathList = [];
      isKeepAnnotation = true;
      if (nameMatch = defineStr.match(namesReg)) {
        nameList = this.parseRequireStr(nameMatch[1]);
      }
      if (pathMatch = defineStr.match(pathsReg)) {
        pathList = this.parseRequireStr(pathMatch[1], isKeepAnnotation);
      }
      if (!pathList.length) {
        return this;
      }
      requires = [];
      for (i = _i = 0, _len = pathList.length; _i < _len; i = ++_i) {
        pathStr = pathList[i];
        if (i < nameList.length) {
          nameStr = nameList[i];
        }
        if (!nameStr) {
          nameStr = globalFLag + pathStr.replace(specialCharReg, specialCharStr);
        }
        equires.push("  " + nameStr + " = require('" + pathStr + "')");
      }
      this.requires = requires;
      return this;
    };

    Formator.prototype.format = function() {
      var headers, list, requires, tails;
      this.initStartAndEnd().initRequires();
      if (this.start < 0) {
        return this.fileList;
      }
      list = this.fileList;
      headers = list.slice(0, this.start);
      requires = this.requires;
      tails = list.slice(this.end);
      if (this.hasWrapper(headers.push(withWrapperStr))) {

      } else {
        headers.push(noWrapperStr);
      }
      return headers.concat(requires).concat(tails);
    };

    return Formator;

  })();

  module.exports = function(fileList, options) {
    var formator;
    formator = new Formator(fileList, options);
    return formator.format();
  };

}).call(this);
