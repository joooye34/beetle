// Generated by CoffeeScript 1.8.0
(function() {
  var Formator, group, requireNameReg, requireReg, util;

  util = require('../util');

  requireReg = /\=[\s\S]*require/;

  requireNameReg = /(^\s*\S*\s*)(=[\s\S]*)/;

  group = [/\w+model\s+/i, /\w+collection\s+/i, /\w+view\s+/i, /\w+template\s+/i, /^\s*G_/];

  Formator = (function() {
    function Formator(fileList, options) {
      var i, item;
      this.fileList = fileList;
      for (i in options) {
        item = options[i];
        this[i] = item;
      }
    }

    Formator.prototype.fileList = [];

    Formator.prototype.start = -1;

    Formator.prototype.end = -1;

    Formator.prototype.headers = [];

    Formator.prototype.requires = [];

    Formator.prototype.tails = [];

    Formator.prototype.groupNumber = 6;

    Formator.prototype.maxNameLength = 0;

    Formator.prototype.initStartAndEnd = function() {
      var i, line, list, match, nameStr, preSpace, _i, _len;
      list = this.fileList;
      preSpace = -1;
      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
        line = list[i];
        if (util.isSpaceLine(line) || util.isAnnotation(line)) {
          continue;
        }
        if (this.start < 0 && requireReg.test(line)) {
          this.start = i;
        }
        if (requireReg.test(line)) {
          match = line.match(requireNameReg);
          nameStr = match[1] || '';
          nameStr = nameStr.trim();
          if (nameStr.length > this.maxNameLength) {
            this.maxNameLength = nameStr.length;
          }
        }
        this.end = i;
        if (this.start >= 0 && !requireReg.test(line)) {
          break;
        }
      }
      return this;
    };

    Formator.prototype.initRequires = function() {
      var list;
      list = this.fileList;
      this.headers = list.slice(0, this.start);
      this.requires = list.slice(this.start, this.end);
      this.tails = list.slice(this.end);
      return this;
    };

    Formator.prototype.space = function() {
      var firstTail, lastHeader;
      lastHeader = this.headers[this.headers.length - 1];
      firstTail = this.tails[0];
      if (!util.isSpaceLine(lastHeader) && !util.isAnnotation(lastHeader)) {
        this.headers.push('');
      }
      if (!util.isSpaceLine(firstTail) && !util.isAnnotation(firstTail)) {
        this.tails.unshift('');
      }
      return this;
    };

    Formator.prototype.align = function() {
      var alignList, i, line, list, match, nameStr, tailStr, _i, _len;
      list = this.requires;
      alignList = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        line = list[_i];
        match = line.match(requireNameReg);
        if (match) {
          nameStr = match[1] || '';
          nameStr = nameStr.trim();
          tailStr = match[2] || '';
          tailStr = tailStr.trim();
          i = nameStr.length;
          while (i++ < this.maxNameLength) {
            nameStr += ' ';
          }
          alignList.push("  " + nameStr + " " + tailStr);
        }
      }
      this.requires = alignList;
      return this;
    };

    Formator.prototype.compare = function(a, b) {
      var aBig, a_char, abEqual, bBig, b_char, i, parseChar;
      aBig = 1;
      abEqual = 0;
      bBig = -1;
      if (!a && !b) {
        return abEqual;
      } else if (a && !b) {
        return aBig;
      } else if (!a && b) {
        return bBig;
      }
      parseChar = function(c) {
        if (/[^a-zA-Z]/.test(c)) {
          return "1" + c;
        } else if (/[a-z]/.test(c)) {
          return "2" + c;
        } else if (/[A-Z]/.test(c)) {
          return "3" + c;
        }
        return c;
      };
      a = "" + a;
      b = "" + b;
      i = 0;
      while (i++ < a.length) {
        if (i >= b.length) {
          return aBig;
        }
        a_char = parseChar(a[i]);
        b_char = parseChar(b[i]);
        if (a_char > b_char) {
          return aBig;
        } else if (a_char < b_char) {
          return bBig;
        }
      }
      if (i < b.length) {
        return bBig;
      }
      return abEqual;
    };

    Formator.prototype.sort = function() {
      var isNotOther, line, list, map, reg, requires, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      requires = this.requires.sort(this.compare);
      if (requires.length > this.groupNumber) {
        map = {
          other: []
        };
        for (_i = 0, _len = group.length; _i < _len; _i++) {
          reg = group[_i];
          map["" + reg] = [];
        }
        for (_j = 0, _len1 = requires.length; _j < _len1; _j++) {
          line = requires[_j];
          if (util.isSpaceLine(line) || util.isAnnotation(line)) {
            continue;
          }
          isNotOther = false;
          for (_k = 0, _len2 = group.length; _k < _len2; _k++) {
            reg = group[_k];
            if (!reg.test(line)) {
              continue;
            }
            isNotOther = true;
            map["" + reg].push(line);
            break;
          }
          if (!isNotOther) {
            map.other.push(line);
          }
        }
        requires = map.other;
        for (_l = 0, _len3 = group.length; _l < _len3; _l++) {
          reg = group[_l];
          list = map["" + reg];
          if (list.length > 0) {
            requires.push('');
          }
          requires = requires.concat(list);
        }
      }
      this.requires = requires;
      return this;
    };

    Formator.prototype.format = function() {
      this.initStartAndEnd();
      if (this.start < 0) {
        return this.fileList;
      }
      this.initRequires().space().align().sort();
      return this.headers.concat(this.requires).concat(this.tails);
    };

    return Formator;

  })();

  module.exports = function(fileList, options) {
    var formator;
    formator = new Formator(fileList, options);
    return formator.format();
  };

}).call(this);
